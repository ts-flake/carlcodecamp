## é¢˜ç›®
[98.éªŒè¯äºŒå‰æœç´¢æ ‘ | åŠ›æ‰£é¢˜ç›®](https://leetcode.cn/problems/validate-binary-search-tree/description/)

éªŒè¯ä¸€é¢—äºŒå‰æ ‘æ˜¯ä¸æ˜¯äºŒå‰æœç´¢æ ‘.

## åˆæ­¥è§£ç­”
ğŸ•³ï¸ä¸€å¼€å§‹å°±æ‰å‘é‡Œäº†, ä¸Šæ¥å°±âŒ*å‰åºé€’å½’æ£€æŸ¥å·¦å³èŠ‚ç‚¹å¤§å°*, ğŸš¨æ³¨æ„äºŒå‰æœç´¢æ ‘æ˜¯è¦æ±‚**å·¦**å­æ ‘**æ‰€æœ‰**éç©ºèŠ‚ç‚¹å€¼å‡**å°äº**æ ¹èŠ‚ç‚¹å€¼, **å³**å­æ ‘**æ‰€æœ‰**éç©ºèŠ‚ç‚¹å€¼å‡**å¤§äº**æ ¹èŠ‚ç‚¹å€¼. å•å±‚é€’å½’æ˜¯æ²¡ç”¨çš„!!

æ ¹æ®æç¤º, å…ˆ**ä¸­åºéå†**æŠŠäºŒå‰æ ‘è½¬æ¢æˆæ•°ç»„, å†æ ¹æ®äºŒå‰æœç´¢æ ‘çš„æ€§è´¨, æ£€æŸ¥æ•°ç»„æ˜¯å¦**ä¸¥æ ¼é€’å¢**.

**é€’å½’+æ•°ç»„**:
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        vals = []
        def _traverse(node):
            if not node: return
            _traverse(node.left)
            vals.append(node.val)
            _traverse(node.right)
        
        _traverse(root)
        
        max_val = vals.pop()
        while vals:
            if vals[-1] >= max_val: return False
            max_val = vals.pop()
        return True
```

## å‚è€ƒè§£ç­”
ä¸ç”¨å…ˆè½¬æ¢æˆæ•°ç»„ä¹Ÿæ˜¯å¯ä»¥çš„. åŒæ ·æ˜¯åˆ©ç”¨äº†**äºŒå‰æœç´¢æ ‘åœ¨ä¸­åºéå†ä¸‹æ˜¯ä¸¥æ ¼å•è°ƒé€’å¢**çš„æ€§è´¨.

**é€’å½’**:
```python
class Solution:
    def __init__(self):
        self.maxVal = float('-inf')  # å› ä¸ºåå°æµ‹è¯•æ•°æ®ä¸­æœ‰intæœ€å°å€¼

    def isValidBST(self, root):
        if root is None:
            return True

        left = self.isValidBST(root.left)
        # ä¸­åºéå†ï¼ŒéªŒè¯éå†çš„å…ƒç´ æ˜¯ä¸æ˜¯ä»å°åˆ°å¤§
        if self.maxVal < root.val:
            self.maxVal = root.val
        else:
            return False
        right = self.isValidBST(root.right)

        return left and right
```

## å¿ƒå¾—
âœ…**äºŒå‰æœç´¢æ ‘åœ¨ä¸­åºéå†ä¸‹æ˜¯ä¸¥æ ¼å•è°ƒé€’å¢**.