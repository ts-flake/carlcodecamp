## é¢˜ç›®
[110.å¹³è¡¡äºŒå‰æ ‘ | åŠ›æ‰£é¢˜ç›®](https://leetcode.cn/problems/balanced-binary-tree/description/)

**å¹³è¡¡äºŒå‰æ ‘**æŒ‡çš„æ˜¯å·¦å³å­æ ‘çš„**é«˜åº¦**å·®ä¸è¶…è¿‡ 1.

## åˆæ­¥è§£ç­”
æ ¹æ®å®šä¹‰, ååºé€’å½’éå†æ±‚èŠ‚ç‚¹çš„é«˜åº¦, ç„¶åååºéå†æ£€æŸ¥å¹³è¡¡äºŒå‰æ ‘.
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def _height(node):
            if not node: return 0
            return max(_height(node.left), _height(node.right)) + 1

        def _traverse(node):
            if not node: return True
            lheight = _height(node.left)
            rheight = _height(node.right)
            if abs(lheight - rheight) > 1: return False
            lcheck = _traverse(node.left)  # å·¦
            rcheck = _traverse(node.right) # å³
            return lcheck and rcheck       # ä¸­
        return _traverse(root)
```

## å‚è€ƒè§£ç­”
```python
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if self.get_height(root) != -1:
            return True
        else:
            return False

    def get_height(self, root: TreeNode) -> int:
        # Base Case
        if not root:
            return 0
        # å·¦
        if (left_height := self.get_height(root.left)) == -1: # walrus operator :=
            return -1
        # å³
        if (right_height := self.get_height(root.right)) == -1:
            return -1
        # ä¸­
        if abs(left_height - right_height) > 1:
            return -1
        else:
            return 1 + max(left_height, right_height)
```


## å¿ƒå¾—
ğŸš¨**é«˜åº¦**å’Œ**æ·±åº¦**å…¶å®éƒ½æ˜¯å…³äºä¸€ä¸ª**èŠ‚ç‚¹**åœ¨ä¸€é¢—æ ‘ç§çš„æ¦‚å¿µ, åªæ˜¯åŸºå‡†çº¿ä¸åŒ.