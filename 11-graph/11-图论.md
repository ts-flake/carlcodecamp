---
status: 🔄进行
start: 2025-06-15
due: 2025-06-24
topic:
  - 算法
  - 代码随想录
tags:
  - project/代码随想录算法营
  - 计算机/算法
  - 知识点
recommend: 5
priority: 1
authors:
  - Donghan
dg-publish: false
---
## 知识点
图的一般分类:
- 有/无向
- 有/无权

图相关概念:
- **节点**和**边**
- **节点的度** - 对于有向图度又分为出/入度
- **图的连通性** - 对于无向图有连通图, 连通分量概念; 对于有向图有强连通, 强连通分量概念.

图的构造/表示:
- "朴素"表示 - 用**二元对**来记录所有的**边**
- **邻接矩阵** - 常用表示, 易于操作, 但对于系数图, 空间利用率不高
- **邻接表** - 数组和链表的组合, 用链表记录每个节点的边; 表示和操作复杂, 但适合于稀疏图

🔍图的遍历/搜索:
- 搜索算法的**参数** - 图 (存储已知信息), 起点和终点
- **DFS** - 深度优先, [[07-回溯算法]]其实就是 DFS
- **BFS** - 广度优先, 通常用于解决最短路径, 因为搜索是一圈一圈向外展开的, 所以一旦碰到终点, 得到的路径就是最"短"的

注意 DFS/BFS 只是搜索策略, 可以在不同的数据结构上搜索. 回顾一下, 在二叉树里的 DFS 就是 [[06-二叉树-二叉树的递归遍历]]或 [[06-二叉树-二叉树的迭代遍历]], 而 BFS 就是 [[06-二叉树-二叉树的层序遍历]]. 在图上进行搜索就是在*图表示*上运用 DFS/BFS 来搜索.

![[graph_bfs1.png|300]] ![[graph_bfs2.png|300]]

### 并查集
>**并查集**是一种**树型**的数据结构, 用于处理一些**不相交集合** (disjoint sets) 的合并及查询问题.

并查集的作用是:
- 将两个 (多个) 元素添加到一个类; 换而言之, 当我们有一些元素, 这些元素要划分成 (很多) 集合, 并查集的作用就是**构建/记录这些集合**
- **查询**任意两个元素是否属于同一集合

❓上面的两个功能 set 就能满足, 为什么还要并查集? 并查集适合处理**划分很多**的情况, 这时候都需要管理很多个 set 或 list.

并查集的基本原理:
- 把集合的从属/连通关系用**有向图/树形结构**表示, 即将集合里的某个元素当做是根 (依据添加元素的过程而改变), 所有属于该集合的元素都有相同的根
- 用一个**数组/字典**来记录有向图的连接关系, 例如, `father[i]=j` 表示节点 `i` 的父节点是 `j`
- 避免寻根的时候递归深度过大, 通过**路径压缩**来将**节点和根直接相连**
![[graph_union_find1.png|300]] ![[graph_union_find2.png|300]]

✅C++ 的**并查集模版**如下:
```cpp
int n = 1005; // n根据题目中节点数量而定，一般比节点数量大一点就好
vector<int> father = vector<int> (n, 0); // C++里的一种数组结构

// 并查集初始化
void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
    }
}
// 并查集里寻根的过程
int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]); // 路径压缩
}

// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}

// 将v->u 这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}
```


## 理解

## 心得


---
## links
>***Note***: 🚨图论系列的题目采用的是 **ACM 模式**, 而不再是力扣那样的**核心代码模式**. 即写代码时还要关注输入输出的处理, 以及图表示 (例如邻接矩阵). 可以通过下面的题目慢慢熟悉起来.

🔍**深度/广度搜索**:
- [[11-图论-所有可达路径]] - 所有可达路径问题在**二/N叉树递归遍历**或**回溯算法**里都做过, 其实都是 DFS
- [[11-图论-字符串接龙]] - ✅**BFS 搜索最短路径**
- [[11-图论-有向图的完全可达性]] -  理解有向图和可达性; 体会 **DFS 的两种写法的微妙区别**

🏝️**岛屿/染色问题**:
- [[11-图论-岛屿数量 DFS]] - 岛屿数量只需要遍历一遍图并记录数量, 和*遍历方式无关*, 所以 DFS/BFS 都能做
- [[11-图论-岛屿数量 BFS]] - 同上题, 只是把搜索遍历方法改成 BFS
- [[11-图论-岛屿的最大面积]] - 在岛屿数量的代码上小修改就能计算最大面积
- [[11-图论-孤岛的总面积]] - 判断孤岛的一个巧妙办法是先沿着地图边缘标记岛屿, 剩下的岛屿就是孤岛
- [[11-图论-沉没孤岛]] - 继续用上一题的技巧, 先标记非孤岛, 再沉没孤岛
- [[11-图论-水流问题]] - ✅**逆向思维**, 从边界出发, 逆流而上记录可达单元格, 最终返回重复可达的单元格
- [[11-图论-建造最大岛屿]] - 暴力法耗时, 采用**记忆化搜索**用空间换时间, 避免重复搜索
- [[11-图论-岛屿的周长]] - 🚨避免思维惯性, 本题不用 DFS/BFS

**并查集**:
- [[11-图论-寻找存在的路径]] - **并查集**应用之检查两个节点是否在同一个集合里
- [[11-图论-冗余连接]] - **并查集**应用之检查无向图是否有环
- [[11-图论-冗余连接II]] - **并查集**应用之检查有向图是否有环, ✅学会分情况讨论, *学会区分有向树和有向图*

🌲**最小生成树**:
- [[11-图论-最小生成树之Prim]] - **最小生成树**, Prim算法是**贪心地维护节点的集合**.
- [[11-图论-最小生成树之Kruskal]] - **最小生成树**, Kruskal 算法是**贪心地维护边的集合** (每次将最短的边加入树, 这里要判断边的节点在不在最小生成树内, 需要用到并查集). ✅**稠密图 (边远大于节点个数) 推荐 Prim; 稀疏图推荐用 Kruskal**

**拓扑排序**:
- [[11-图论-拓扑排序]] - **拓扑排序**就是**将一个有向图转换成线性序列**. ✅**卡恩算法 (BFS)**: 1. 寻找图中**入度 0** 的节点, 将其加入结果集; 2. 将该节点从图中移除

🧭**最短路径**:
- [[11-图论-Dijkstra朴素版]] - ✅**单源非负权重有向图**的最短路径/距离. 🆚Dijkstra 和 Prim 的对比: (相似) 两者都是贪心, 都有 `minDist`; (不同) Prim 寻找最小生成树, 每次添加**离生成树最近的节点**, 没有连贯路径; Dijkstra 寻找最短路径, 每次添加**离起始点/路径最近的节点**, 路径连贯
- [[11-图论-Dijkstra堆优化]] - 稀疏图时推荐遍历边+堆优化+邻接表
- [[11-图论-Bellman-ford算法]] - ✅**单源负权重有向图**的最短路径/距离
- [[11-图论-SPFA]] - 队列优化 Bellman-ford 算法, 适合于**稀疏图**的情况
- [[11-图论-Bellman-ford之判断负权回路]] - 利用过度松弛来判断负回环
- [[11-图论-Bellman-ford 之单源有限路径]] - ✅用`minDist_copy`更新保证 **`k`次松弛的值等于`<=k`内从起点到达所需最短开销**; 最短路径带**不等式约束**
- [[11-图论-Floyd算法]] - ✅**多源 (可正可负权重) 图**的最短路径/距离, 本质仍是动态规划
- [[11-图论-A*算法]] - ✅**启发 (heuristic) 式搜索**算法, 是 BFS 或 Dijkstra 的改良版: 引入了**启发函数**用于*估计*当前位置到终点的距离; 利用**优先级队列**, 每次从队伍中取出 `f=g+h=cost-to-come + cost-to-go` 最小的来 expand; ❌不能保证路径是最短的, 即得到的是**次短路径** (用速度换精度); ❌不适合寻找多个潜在终点的最短路径, 后者用 BFS, Dijkstra 或 Floyd

## reference
[图论理论基础 | 代码随想录](https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
[图论总结 | 代码随想录](https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E6%80%BB%E7%BB%93%E7%AF%87.html)