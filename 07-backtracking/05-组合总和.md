## é¢˜ç›®
[39.ç»„åˆæ€»å’Œ | åŠ›æ‰£é¢˜ç›®](https://leetcode.cn/problems/combination-sum/description/)

ç»™ä½ ä¸€ä¸ª**æ— é‡å¤å…ƒç´ **çš„æ•´æ•°æ•°ç»„ `candidates` å’Œä¸€ä¸ªç›®æ ‡æ•´æ•° `target`, æ‰¾å‡º `candidates` ä¸­å¯ä»¥ä½¿æ•°å­—å’Œä¸ºç›®æ ‡æ•° `target` çš„æ‰€æœ‰**ä¸åŒç»„åˆ**, å¹¶ä»¥åˆ—è¡¨å½¢å¼è¿”å›. `candidates` ä¸­çš„**åŒä¸€ä¸ª**æ•°å­—å¯ä»¥**æ— é™åˆ¶é‡å¤è¢«é€‰å–**.

## åˆæ­¥è§£ç­”
å› ä¸ºå…ƒç´ å¯ä»¥é‡å¤åˆ©ç”¨, æ¯ä¸ªèŠ‚ç‚¹çš„å­é›†å‡ä¸º `candidates`, é€’å½’ç»“æŸæ¡ä»¶ä¸ºå½“å‰è·¯å¾„é•¿åº¦å¤§äºç›®æ ‡å€¼. ä¿è¯ç»“æœæ˜¯ä¸åŒçš„ç»„åˆ, å¯ä»¥ç”¨ set æ¥å®ç°.
```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = set()
        def backtracking(l, path, path_length):
            if path_length > target: return # ç»“æŸæ¡ä»¶
            if path_length == target:
                res.add(tuple(sorted(path))) # å»é‡
                return
            
            for x in l:
                backtracking(l, path+[x], path_length+x)
        
        backtracking(candidates, [], 0)
        return list(res)
```

## å‚è€ƒè§£ç­”
ğŸš¨å› ä¸ºå…ƒç´ èƒ½æ— é™é‡å¤, æ‰€ä»¥å¦‚æœ `candidates` åŒ…å« 0, ä»£ç å°±ä¼š stack overflow. å¥½åœ¨é¢˜ç›®å‡è®¾ä¸ä¼šå‡ºç° 0.

âœ…ä¿è¯ç»“æœæ˜¯ä¸åŒçš„ç»„åˆ, å¯ä»¥å…ˆå¯¹æ•°ç»„**æ’åº**, å°±èƒ½é¿å…ä½¿ç”¨ set å‰”é™¤æ’åˆ—. å› ä¸ºæ’åºååªå­˜åœ¨ä¸€ä¸ªåº, åªç•™ç»„åˆ.
```python
class Solution:
    def backtracking(self, candidates, target, total, startIndex, path, result):
        if total == target:
            result.append(path[:])
            return

        for i in range(startIndex, len(candidates)):
            if total + candidates[i] > target:
                break
            total += candidates[i]
            path.append(candidates[i])
            self.backtracking(candidates, target, total, i, path, result)
            total -= candidates[I] # æ˜¾å¼å›æº¯
            path.pop() # æ˜¾å¼å›æº¯

    def combinationSum(self, candidates, target):
        result = []
        candidates.sort()  # éœ€è¦æ’åº
        self.backtracking(candidates, target, 0, 0, [], result)
        return result
```

## å¿ƒå¾—
æ ¹æ®å‚è€ƒè§£ç­”, å°†åˆæ­¥è§£ç­”ä¿®æ”¹å¦‚ä¸‹:
```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        def backtracking(l, path, path_length):
            if path_length == target:
                res.append(path)
                return
            
            for i,x in enumerate(l):
                if path_length+x > target: break # å‰ªæ
                backtracking(l[i:], path+[x], path_length+x) # çºµå‘é€’å½’, æ³¨æ„ l[i:] çš„ startIndex=i æ„å‘³ç€å…è®¸å…ƒç´ é‡å¤
        
        backtracking(sorted(candidates), [], 0) # å…ˆæ’åº
        return res
```

âœ…ä¸è€ƒè™‘æ’åº=å…ˆæ’ä¸ªåº