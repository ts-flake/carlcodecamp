## é¢˜ç›®
[47.å…¨æ’åˆ—II | åŠ›æ‰£é¢˜ç›®](https://leetcode.cn/problems/permutations-ii/description/)

ç»™å®šä¸€ä¸ª**åŒ…å«**é‡å¤æ•°å­—çš„æ•°ç»„ `nums`, è¿”å›å…¶æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ—. ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆ.

## åˆæ­¥è§£ç­”
ç›¸è¾ƒäº [[07-å›æº¯ç®—æ³•-å…¨æ’åˆ—]], è¿™é‡Œè¦è€ƒè™‘**å»é‡**äº†.
```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        used = [0]*len(nums)
        def backtracking(nums, start, path, used):
            if len(path) == len(nums): # ç»ˆæ­¢æ¡ä»¶
                res.append(path[:])
                return

            for i in range(start, len(nums)):
                if i > 0 and nums[i] == nums[i-1] and used[i-1] == 0: # used[i-1]==0 æ„å‘³ç€åŒå±‚, åŒå±‚å»é‡ ğŸ‘ˆ
                    continue
                if used[i] == 1: continue # used è®°å½• path å‡ºç°è¿‡çš„å…ƒç´ , ç›¸å½“äºä»ä½™ä¸‹çš„å…ƒç´ é‡Œé€‰æ‹©
                path.append(nums[i])
                used[i] = 1
                backtracking(nums, 0, path, used)
                path.pop() # æ˜¾å¼å›æº¯
                used[i] = 0
            
        backtracking(sorted(nums), 0, [], used) # å»é‡è¦å…ˆæ’åº
        return res
```

## å‚è€ƒè§£ç­”

```python
class Solution:
    def permuteUnique(self, nums):
        nums.sort()  # æ’åº
        result = []
        self.backtracking(nums, [], [False] * len(nums), result)
        return result

    def backtracking(self, nums, path, used, result):
        if len(path) == len(nums):
            result.append(path[:])
            return
        for i in range(len(nums)):
            if (i > 0 and nums[i] == nums[i - 1] and not used[i - 1]) or used[i]:
                continue
            used[i] = True
            path.append(nums[i])
            self.backtracking(nums, path, used, result)
            path.pop()
            used[i] = False
```


## å¿ƒå¾—