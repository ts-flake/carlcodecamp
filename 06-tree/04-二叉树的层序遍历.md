## é¢˜ç›®
[102.äºŒå‰æ ‘çš„å±‚åºéå† | åŠ›æ‰£é¢˜ç›®](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)
[107.äºŒå‰æ ‘çš„å±‚æ¬¡éå†II | åŠ›æ‰£é¢˜ç›®](opens new window)
[199.äºŒå‰æ ‘çš„å³è§†å›¾ | åŠ›æ‰£é¢˜ç›®](opens new window)
[637.äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼ | åŠ›æ‰£é¢˜ç›®](opens new window)
[429.Nå‰æ ‘çš„å±‚åºéå† | åŠ›æ‰£é¢˜ç›®](opens new window)
[515.åœ¨æ¯ä¸ªæ ‘è¡Œä¸­æ‰¾æœ€å¤§å€¼ | åŠ›æ‰£é¢˜ç›®](opens new window)
[116.å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ | åŠ›æ‰£é¢˜ç›®](opens new window)
[117.å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆII | åŠ›æ‰£é¢˜ç›®](opens new window)
[104.äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ | åŠ›æ‰£é¢˜ç›®](opens new window)
[111.äºŒå‰æ ‘çš„æœ€å°æ·±åº¦ | åŠ›æ‰£é¢˜ç›®]

äºŒå‰æ ‘çš„å±‚åºéå†, å°±æ˜¯ **BFS å¹¿åº¦ä¼˜å…ˆæœç´¢**.

## åˆæ­¥è§£ç­”
å±‚åºéå†å¯ä»¥ç”¨é˜Ÿåˆ—å®ç°, FIFO.

1ï¸âƒ£102.äºŒå‰æ ‘çš„å±‚åºéå†
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from collections import deque
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root: return []
        queue = deque([root])
        rows = []
        while queue:
            row = []
            for _ in range(len(queue)): # len(queue) = è¯¥å±‚èŠ‚ç‚¹æ•°, ä»å·¦åˆ°å³ä¾æ¬¡éå†
                node = queue.popleft()
                row.append(node.val)
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            rows.append(row)
        return rows
```

2ï¸âƒ£107.äºŒå‰æ ‘çš„å±‚æ¬¡éå†II, å’Œä¸Šé¢˜ä¸€æ ·, ç»“æœåè½¬ä¸€ä¸‹, å®ç°è‡ªä¸‹è€Œä¸Š, ä»å·¦åˆ°å³éå†.
```python
from collections import deque
class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root: return []
        queue = deque([root])
        rows = []
        while queue:
            row = []
            for _ in range(len(queue)): # len(queue) = è¯¥å±‚èŠ‚ç‚¹æ•°, ä»å·¦åˆ°å³ä¾æ¬¡éå†
                node = queue.popleft()
                row += node.val
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            rows.append(row)
        return rows[::-1]
```

3ï¸âƒ£199.äºŒå‰æ ‘çš„å³è§†å›¾, å³åœ¨å¹³é¢å›½å†…, ç«™åœ¨ä¸€é¢—æ ‘çš„å³è¾¹çœ‹, ä¼šçœ‹åˆ°ä»€ä¹ˆ. è‡ªä¸Šè€Œä¸‹è¿”å›ç»“æœ. ä»»ç„¶æ˜¯å±‚åºéå†, åªè®°å½•æœ€å³è¾¹çš„å€¼å°±å¥½.
```python
from collections import deque
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        if not root: return []
        queue = deque([root])
        rows = []
        while queue:
            row = None
            for _ in range(len(queue)): # len(queue) = è¯¥å±‚èŠ‚ç‚¹æ•°, ä»å·¦åˆ°å³ä¾æ¬¡éå†
                node = queue.popleft()
                row += node.val
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            rows.append(row)
        return rows
```

4ï¸âƒ£637.äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼, è‡ªä¸Šè€Œä¸‹è¿”å›æ¯å±‚çš„å¹³å‡å€¼.
```python
from collections import deque
class Solution:
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:
        if not root: return []
        queue = deque([root])
        rows = []
        while queue:
            row = 0
            n = len(queue)
            for _ in range(n): # len(queue) = è¯¥å±‚èŠ‚ç‚¹æ•°, ä»å·¦åˆ°å³ä¾æ¬¡éå†
                node = queue.popleft()
                row += node.val
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            rows.append(row/n)
        return rows
```

5ï¸âƒ£429.Nå‰æ ‘çš„å±‚åºéå†, å­èŠ‚ç‚¹å¯ä»¥å¤§äºä¸¤ä¸ª.
```python
from collections import deque
class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        if not root: return []
        queue = deque([root])
        rows = []
        while queue:
            row = []
            for _ in range(len(queue)): # len(queue) = è¯¥å±‚èŠ‚ç‚¹æ•°, ä»å·¦åˆ°å³ä¾æ¬¡éå†
                node = queue.popleft()
                row.append(node.val)
                if node.children:
                    queue.extend(node.children)
            rows.append(row)
        return rows
```

6ï¸âƒ£515.åœ¨æ¯ä¸ªæ ‘è¡Œä¸­æ‰¾æœ€å¤§å€¼
```python
from collections import deque
class Solution:
    def largestValues(self, root: Optional[TreeNode]) -> List[int]:
        if not root: return []
        queue = deque([root])
        rows = []
        while queue:
            row = -float('inf')
            for _ in range(len(queue)): # len(queue) = è¯¥å±‚èŠ‚ç‚¹æ•°, ä»å·¦åˆ°å³ä¾æ¬¡éå†
                node = queue.popleft()
                row = max(row, node.val)
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            rows.append(row)
        return rows
```

7ï¸âƒ£116.å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ
8ï¸âƒ£117.å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆII, è¿™ä¸¤é¢˜ä¸€ä¸ªæ˜¯å®Œå…¨äºŒå‰æ ‘, ä¸€ä¸ªæ˜¯äºŒå‰æ ‘, ä½†è§£æ³•ç›¸åŒ, æ²¡æœ‰åŒºåˆ«.
```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""
from collections import deque
class Solution:
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        if not root: return root
        queue = deque([root])

        while queue:
            row = []
            for _ in range(len(queue)): # len(queue) = è¯¥å±‚èŠ‚ç‚¹æ•°, ä»å·¦åˆ°å³ä¾æ¬¡éå†
                node = queue.popleft()
                row.append(node)
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            for ri,rj in zip(row[:-1], row[1:]+[None]):
                ri.next = rj
        return root
```


9ï¸âƒ£104.äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦, å±‚åºéå†å°±æ˜¯åœ¨è®¡ç®—æœ€å¤§æ·±åº¦.
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from collections import deque
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root: return 0

        queue = deque([root])
        depth = 0
        while queue:
            depth += 1
            for _ in range(len(queue)): # len(queue) = è¯¥å±‚èŠ‚ç‚¹æ•°, ä»å·¦åˆ°å³ä¾æ¬¡éå†
                node = queue.popleft()
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
        return depth
```

ğŸ”Ÿ111.äºŒå‰æ ‘çš„æœ€å°æ·±åº¦, å³æ‰¾å‡ºæœ€æµ…çš„, å…œåº•çš„é‚£ä¸€å±‚. ä¸€å±‚æ˜¯å…œåº•çš„, è‹¥å…¶åŒ…å«å¶å­èŠ‚ç‚¹.
```python
from collections import deque
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root: return 0

        queue = deque([root])
        depth = 0
        while queue:
            depth += 1
            for _ in range(len(queue)): # len(queue) = è¯¥å±‚èŠ‚ç‚¹æ•°, ä»å·¦åˆ°å³ä¾æ¬¡éå†
                node = queue.popleft()
                if not node.left and not node.right: # è¯¥å±‚åŒ…å«å¶å­èŠ‚ç‚¹
                      return depth
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
        return depth
```

## å‚è€ƒè§£ç­”

## å¿ƒå¾—
ä¸€ä¸ªå±‚åºéå†æ¨¡ç‰ˆè§£å†³å¤šé¢˜.