## é¢˜ç›®
[144.äºŒå‰æ ‘çš„å‰åºéå† | åŠ›æ‰£é¢˜ç›®](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)
[94.äºŒå‰æ ‘çš„ä¸­åºéå† | åŠ›æ‰£é¢˜ç›®](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)
[145.äºŒå‰æ ‘çš„ååºéå† | åŠ›æ‰£é¢˜ç›®](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)

## åˆæ­¥è§£ç­”
æŒ‰ç…§é€’å½’ä¸‰è¦ç´ ä¸¥æ ¼åœ°å†™ä¸€ä¸‹äºŒå‰æ ‘çš„é€’å½’éå†ä»£ç .
- é€’å½’å‡½æ•° `_traverse` çš„å‚æ•°ä¸ºå­æ ‘å’Œ list (ç”¨äºè®°å½•èŠ‚ç‚¹å€¼)
- ç»ˆæ­¢æ¡ä»¶æ˜¯ç©ºèŠ‚ç‚¹
- å•å±‚é€»è¾‘æ˜¯å‘ list é‡Œæ·»åŠ å½“å‰èŠ‚ç‚¹çš„å€¼

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        def _traverse(root, l):
            if not root: return
            l.append(root.val)       # å‰åº
            _traverse(root.left, l)
            # l.append(root.val)     # ä¸­åº
            _traverse(root.right, l)
            # l.append(root.val)     # ååº
            return l
        
        res = []
        _traverse(root, res)
        return res
```

## å‚è€ƒè§£ç­”
```python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        
        def dfs(node):
            if node is None: return
            res.append(node.val)     # å‰åº
            dfs(node.left)
            # res.append(node.val)   # ä¸­åº
            dfs(node.right)
            # res.append(node.val)   # ååº
        dfs(root)
        return res
```


## å¿ƒå¾—
âœ…**é€’å½’ä¸‰è¦ç´ **:
- é€’å½’å‡½æ•°çš„**å‚æ•°**å’Œ**è¿”å›å€¼**
- é€’å½’**ç»ˆæ­¢æ¡ä»¶**
- **å•å±‚é€’å½’å¤„ç†é€»è¾‘**

ğŸŒ²äºŒå‰æ ‘çš„**å‰/ä¸­/ååº**éå†å°±æ˜¯**å•å±‚é€»è¾‘æ‰§è¡Œçš„ä½ç½®**.