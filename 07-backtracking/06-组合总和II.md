## é¢˜ç›®
[40.ç»„åˆæ€»å’ŒII | åŠ›æ‰£é¢˜ç›®]()

ç»™ä½ ä¸€ä¸ª**æœ‰é‡å¤å…ƒç´ **çš„æ•´æ•°æ•°ç»„ `candidates` å’Œä¸€ä¸ªç›®æ ‡æ•´æ•° `target`, æ‰¾å‡º `candidates` ä¸­å¯ä»¥ä½¿æ•°å­—å’Œä¸ºç›®æ ‡æ•° `target` çš„æ‰€æœ‰**ä¸åŒç»„åˆ**, å¹¶ä»¥åˆ—è¡¨å½¢å¼è¿”å›ž. `candidates` ä¸­çš„**åŒä¸€ä¸ª**æ•°å­—**åªèƒ½ç”¨ä¸€æ¬¡**.

## åˆæ­¥è§£ç­”
è¿™å›ž `candidates` æœ‰é‡å¤å…ƒç´ , ä¸”ç»“æžœåŒæ ·è¦åŽ»é‡. æŒ‰ç…§é¢˜æ„æŠŠ [[07-å›žæº¯ç®—æ³•-ç»„åˆæ€»å’Œ]]çš„ä»£ç æ”¹æ”¹å°±å¥½äº†å§?
```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = set()
        def backtracking(l, path, path_length):
            if (path_length > target or path_length+sum(l) < target
            ): return

            if path_length == target:
                res.add(tuple(sorted(path))) # åŽ»é‡
                return
            
            for i,x in enumerate(l):
                backtracking(l[i+1:], path+[x], path_length+x)
        
        backtracking(candidates, [], 0)
        return list(res)
```

## å‚è€ƒè§£ç­”
ðŸ‘†ä¸Šé¢çš„ä»£ç è™½æ˜¯æ­£ç¡®, ä½† set åŽ»é‡ä¼šè¶…æ—¶. â“å¦‚ä½•åšåˆ°é€’å½’æ—¶å¿«é€ŸåŽ»é‡å‘¢? è¿™é‡Œå°±éœ€è¦å¯¹**åŽ»é‡**åšç»†è‡´åˆ†æž.

âœ…åŽ»é‡æœ‰ä¸¤ç§: **åŒå±‚åŽ»é‡**, **åŒè·¯å¾„åŽ»é‡**. æœ¬é¢˜çš„åŽ»é‡æ˜¯åŒå±‚åŽ»é‡.
```python
class Solution:
    def backtracking(self, candidates, target, total, startIndex, path, result):
        if total == target:
            result.append(path[:])
            return

        for i in range(startIndex, len(candidates)):
            if i > startIndex and candidates[i] == candidates[i - 1]: # åŒå±‚åŽ»é‡
                continue

            if total + candidates[i] > target: # å‰ªæž
                break

            total += candidates[I]
            path.append(candidates[i])
            self.backtracking(candidates, target, total, i + 1, path, result)
            total -= candidates[I] # æ˜¾å¼å›žæº¯
            path.pop() # æ˜¾å¼å›žæº¯

    def combinationSum2(self, candidates, target):
        result = []
        candidates.sort() # ðŸš¨æŽ’åºå¾ˆé‡è¦, ä¸ç„¶åŒå±‚åŽ»é‡é€»è¾‘å¤±æ•ˆ
        self.backtracking(candidates, target, 0, 0, [], result)
        return result
```

## å¿ƒå¾—
æ ¹æ®å‚è€ƒè§£ç­”, å°†åˆæ­¥è§£ç­”ä¿®æ”¹å¦‚ä¸‹:
```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        def backtracking(l, path, path_length):
            if path_length == target:
                res.append(path)
                return
            
            for i,x in enumerate(l):
                if i > 0 and x == l[i-1]: continue # åŽ»é‡
                if (path_length > target or path_length+sum(l) < target): break # å‰ªæž
                backtracking(l[i+1:], path+[x], path_length+x) # æ³¨æ„ startIndex=i+1
        
        backtracking(sorted(candidates), [], 0) # å…ˆæŽ’åº
        return res
```

åˆ°ç›®å‰ä¸ºæ­¢, ç»„åˆé—®é¢˜å·²ç»åšäº† 4 ä¸ª: [[07-å›žæº¯ç®—æ³•-ç»„åˆé—®é¢˜]], [[07-å›žæº¯ç®—æ³•-ç»„åˆæ€»å’ŒIII]], [[07-å›žæº¯ç®—æ³•-ç»„åˆæ€»å’Œ]], å’Œ [[07-å›žæº¯ç®—æ³•-ç»„åˆæ€»å’ŒII]].

âœ…è¿™äº›é¢˜éƒ½èƒ½å¥—ç”¨**å›žæº¯æ¨¡ç‰ˆ**, ä½†ä¹Ÿæœ‰åŒºåˆ«. ç½—åˆ—å‡ ç‚¹æ³¨æ„, å¾…ä½“ä¼š:
- `startIndex` - æ¨ªå‘ (åŒå±‚) å’Œçºµå‘ (åŒè·¯å¾„) éåŽ†æ—¶é›†åˆçš„èµ·å§‹ç‚¹å¦‚ä½•é€‰?
- **åŽ»é‡** - åŒå±‚åŽ»é‡è¿˜æ˜¯åŒè·¯å¾„? ç”¨æ²¡ç”¨**æŽ’åº**?
- **å‰ªæž** - èƒ½ä¸èƒ½å‰ªæž, å‰ªæžçš„é€»è¾‘? ðŸš¨æ³¨æ„å‰ªæžæ˜¯åœ¨ for å¾ªçŽ¯é‡Œè¿›è¡Œçš„, ä¸æ˜¯åœ¨é€’å½’çš„ç»ˆæ­¢æ¡ä»¶
- **ç»ˆæ­¢æ¡ä»¶** - é€’å½’å¿…é¡»æœ‰é™/æ ‘æœ‰é™æ·±