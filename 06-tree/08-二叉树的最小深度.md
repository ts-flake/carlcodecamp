## é¢˜ç›®
[111.äºŒå‰æ ‘çš„æœ€å°æ·±åº¦ | åŠ›æ‰£é¢˜ç›®](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

## åˆæ­¥è§£ç­”
è¿™é“é¢˜åœ¨ [[06-äºŒå‰æ ‘-äºŒå‰æ ‘çš„å±‚åºéå†]]é‡Œå·²ç»åšè¿‡äº†, é‚£æ—¶ç”¨çš„æ˜¯å±‚åºéå†çš„æ–¹æ³•. è¿™é‡Œè¯•è¯•**é€’å½’æ³•**.

ç±»ä¼¼ [[06-äºŒå‰æ ‘-äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦]], åŒæ ·æœ‰å‰/ååºé€’å½’æ–¹æ³•, åˆ†åˆ«å¯¹åº”æ±‚æ·±åº¦å’Œé«˜åº¦. ğŸš¨å¤„ç†æœ€å°æ·±åº¦çš„æ—¶å€™è¦**åˆ†æƒ…å†µè®¨è®º**.

**ååºé€’å½’**:
```python
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        def _depth(node):
            if not node: return 0
            dl = _depth(node.left)
            dr = _depth(node.right)
            if not node.left:  # å·¦èŠ‚ç‚¹ä¸ºç©º, æœ€å°æ·±åº¦åœ¨å³ä¾§
                return 1 + dr
            if not node.right: # å³èŠ‚ç‚¹ä¸ºç©º, æœ€å°æ·±åº¦åœ¨å·¦ä¾§
                return 1 + dl
            return 1 + min(dl, dr) # å·¦å³ä¸ä¸ºç©º, å–æœ€å°çš„æ·±åº¦
        return _depth(root)
```

## å‚è€ƒè§£ç­”
**å‰åºé€’å½’**:
```python
class Solution:
    def __init__(self):
        self.result = float('inf')

    def getDepth(self, node, depth):
        if node.left is None and node.right is None: # å·¦å³èŠ‚ç‚¹ä¸ºç©º, å¶å­èŠ‚ç‚¹, æ›´æ–°æœ€å°æ·±åº¦
            self.result = min(self.result, depth)
        if node.left: self.getDepth(node.left, depth + 1)  # å·¦
        if node.right: self.getDepth(node.right, depth + 1) # å³

    def minDepth(self, root):
        if root is None: return 0
        self.getDepth(root, 1)
        return self.result
```

## å¿ƒå¾—