## é¢˜ç›®
[347.å‰Kä¸ªé«˜é¢‘å…ƒç´  | ä¹æ‰£é¢˜ç›®](https://leetcode.cn/problems/top-k-frequent-elements/description/)

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` å’Œä¸€ä¸ªæ•´æ•° `k`, è¯·ä½ è¿”å›å…¶ä¸­å‡ºç°é¢‘ç‡å‰ `k` é«˜çš„å…ƒç´ . ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆ.

## åˆæ­¥è§£ç­”
ç»Ÿè®¡å‡ºç°é¢‘ç‡ + sort çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n + nlog n). 
```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        count = dict()
        for n in nums:
            count[n] = count.get(n, 0) + 1
        
        count = sorted(count.items(), key=lambda x: x[1], reverse=True)
        return [k for k,v in count[:k]]
```

## å‚è€ƒè§£ç­”
ç»Ÿè®¡å‡ºç°é¢‘ç‡æ˜¯å¿…é¡»çš„. è¦ä¼˜åŒ–çš„éƒ¨åˆ†åœ¨æ‰¾å‡ºå‰ `k` é«˜é¢‘å…ƒç´ . å› ä¸ºåªå…³å¿ƒå‰ `k` ä¸ªå…ƒç´ , æ²¡å¿…è¦å¯¹æ‰€æœ‰ `n` ä¸ªå…ƒç´ æ’åº. **ä¼˜å…ˆçº§é˜Ÿåˆ—**æ˜¯ä¸ªä¸é”™çš„é€‰æ‹©.

å…ˆè‡ªå·±å†™ä¸ªä¼˜å…ˆçº§é˜Ÿåˆ—è¯•è¯•çœ‹, ç”¨äº†ä¸¤ä¸ª queue, `q1` ä»¥é™åºæ’åˆ—å…ƒç´ , `q2` ç”¨äºä¸´æ—¶è®°å½•.
```python
from collections import deque
class PriorityQueue:
    def __init__(self):
        self._q1 = deque()
        self._q2 = deque()
    def push(self, x, v):
        while not self.empty() and self._q1[-1][1] < v:
            self._q2.appendleft(self._q1.pop())
        self._q1.append((x,v))
        while self._q2:
            self._q1.append(self._q2.popleft())
    def pop(self):
        return self._q1.pop()
    def empty(self):
        return len(self._q1) == 0
    def get_list(self):
        return [x for x,v in self._q1]
    def __len__(self):
        return len(self._q1)

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        count = dict()
        for n in nums:
            count[n] = count.get(n, 0) + 1
        
        topk = PriorityQueue()
        for x,v in count.items():
            topk.push(x,v)
            while len(topk) > k:
                topk.pop()
        return topk.get_list()
```
è‡ªå·±å†™çš„ä¼˜å…ˆçº§é˜Ÿåˆ—å¢æ·»æ–°å…ƒç´ çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(k), æ‰€ä»¥æ•´ä½“æ—¶é—´å¤æ‚åº¦ä¸º O(nk). è¿™ä¸æ˜¯æœ€ä¼˜çš„. ğŸ‘‡ä¸‹é¢é€šè¿‡ `heapq` çš„å¤§/å°é¡¶å †æ¥å®ç°ä¼˜å…ˆçº§é˜Ÿåˆ—, æ•´ä½“æ—¶é—´å¤æ‚åº¦æ˜¯ O(nlog k).
```python
import heapq
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        #è¦ç»Ÿè®¡å…ƒç´ å‡ºç°é¢‘ç‡
        map_ = {} #nums[i]:å¯¹åº”å‡ºç°çš„æ¬¡æ•°
        for i in range(len(nums)):
            map_[nums[i]] = map_.get(nums[i], 0) + 1
        
        #å¯¹é¢‘ç‡æ’åº
        #å®šä¹‰ä¸€ä¸ªå°é¡¶å †ï¼Œå¤§å°ä¸ºk
        pri_que = [] #å°é¡¶å †
        
        #ç”¨å›ºå®šå¤§å°ä¸ºkçš„å°é¡¶å †ï¼Œæ‰«ææ‰€æœ‰é¢‘ç‡çš„æ•°å€¼
        for key, freq in map_.items():
            heapq.heappush(pri_que, (freq, key))
            if len(pri_que) > k: #å¦‚æœå †çš„å¤§å°å¤§äºäº†Kï¼Œåˆ™é˜Ÿåˆ—å¼¹å‡ºï¼Œä¿è¯å †çš„å¤§å°ä¸€ç›´ä¸ºk
                heapq.heappop(pri_que)
                
        return [k for f,k in pri_que]
```

## å¿ƒå¾—
[[05-æ ˆä¸é˜Ÿåˆ—-æ»‘åŠ¨çª—å£æœ€å¤§å€¼]]é‡Œç”¨äº†â†•ï¸**å•è°ƒé˜Ÿåˆ—**, æœ¬é¢˜ç”¨äº†â«ï¸**ä¼˜å…ˆçº§é˜Ÿåˆ—**, ä¸¤è€…ç›¸ä¼¼åœ¨äºå†…éƒ¨å…ƒç´ æ˜¯æœ‰åºæ’åˆ—çš„ (æ ¹æ®æŸä¸ªæ€§è´¨é€’å¢æˆ–é€’å‡). ä¸åŒåœ¨äºå®ç°å’Œç”¨é€”. âœ…å•è°ƒé˜Ÿåˆ—ç”¨ deque å®ç°, ç”¨é€”åœ¨äºç»´æŠ¤ä¸€åŒºé—´å†…çš„æœ€å€¼. ä¼˜å…ˆçº§é˜Ÿåˆ—ç”¨**å †**å®ç°, ç”¨é€”äºæŒ‰é¡ºåºå–å‡ºå…ƒç´ .