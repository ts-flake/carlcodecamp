## é¢˜ç›®
[144.äºŒå‰æ ‘çš„å‰åºéå† | åŠ›æ‰£é¢˜ç›®](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)
[94.äºŒå‰æ ‘çš„ä¸­åºéå† | åŠ›æ‰£é¢˜ç›®](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)
[145.äºŒå‰æ ‘çš„ååºéå† | åŠ›æ‰£é¢˜ç›®](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)

## åˆæ­¥è§£ç­”
å› ä¸ºåœ¨è®¡ç®—æœºåœ¨æ‰§è¡Œé€’å½’å‡½æ•°æ—¶å…¶å®æ˜¯é€šè¿‡ğŸ¥æ ˆæ¥å®ç°çš„. æ‰€ä»¥æˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨æ ˆ/è¿­ä»£çš„æ–¹æ³•æ¥éå†äºŒå‰æ ‘.

å®ç°æ—¶å¯ä»¥å‚è€ƒé€’å½’éå†çš„è¿‡ç¨‹, åŒæ—¶æ³¨æ„åˆ°æ ˆ LIFO çš„æ“ä½œè§„åˆ™.

**å‰åº**: ä¸­å·¦å³
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = [root]
        while stack:
            node = stack.pop()
            if node:
                res.append(node.val)
                stack.append(node.right)  # å…¥æ ˆ: å…ˆå³åå·¦
                stack.append(node.left)   # å‡ºæ ˆ: å…ˆå·¦åå³
        return res
```

**ååº**: å·¦å³ä¸­ = reverse(å‰åº: ä¸­å³å·¦)
```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = [root]
        while stack:
            node = stack.pop()
            if node:
                res.append(node.val)
                stack.append(node.left)    # å…¥æ ˆ: å…ˆå·¦åå³
                stack.append(node.right)   # å‡ºæ ˆ: å…ˆå³åå·¦
        return res[::-1] # reverse
```

**ä¸­åº**: å·¦ä¸­å³, ä¸åŒäºå‰ä¸¤ä¸ª, æ¯”è¾ƒéš¾å†™, åŸå› åœ¨äº**è®¿é—®èŠ‚ç‚¹ (éå†èŠ‚ç‚¹) å’Œå¤„ç†èŠ‚ç‚¹ (å°†å…ƒç´ æ”¾è¿›ç»“æœé›†) ä¸ä¸€è‡´**. ä¹Ÿå°±æ˜¯è¯´, åœ¨å‰åºéå†æ—¶, éå†åˆ°çš„èŠ‚ç‚¹ä¼šé©¬ä¸Šå¤„ç†, ç”¨å®Œå°±æ‰”, ä¸ä¼šå†æ”¾å› stack.
```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = [root]
        while stack:
            node = stack.pop()
            if node:                     # å…ˆéå†å·¦å­æ ‘ 
                stack.append(node)
                stack.append(node.left)  # å·¦
            elif not node and stack:     # é‡åˆ°ç©ºèŠ‚ç‚¹
                node = stack.pop()
                res.append(node.val)     # ä¸­: è®°å½•
                stack.append(node.right) # å³
        return res
```

## å‚è€ƒè§£ç­”
ä¸­åºå‚è€ƒä»£ç .
```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:

        if not root:
            return []
        stack = []  # ä¸èƒ½æå‰å°†rootèŠ‚ç‚¹åŠ å…¥stackä¸­

        result = []
        cur = root
        while cur or stack:
            # å…ˆè¿­ä»£è®¿é—®æœ€åº•å±‚çš„å·¦å­æ ‘èŠ‚ç‚¹
            if cur:     
                stack.append(cur)
                cur = cur.left		
            # åˆ°è¾¾æœ€å·¦èŠ‚ç‚¹åå¤„ç†æ ˆé¡¶èŠ‚ç‚¹    
            else:		
                cur = stack.pop()
                result.append(cur.val)
                # å–æ ˆé¡¶å…ƒç´ å³èŠ‚ç‚¹
                cur = cur.right	
        return result
```

## å¿ƒå¾—
è¿­ä»£æ³•éå†ä¸åƒé€’å½’é‚£æ ·å¥½å†™, åŸå› æ˜¯å‰/ä¸­/ååºéå†å†™æ³•ä¸ç»Ÿä¸€, å°¤å…¶æ˜¯ä¸­åº.